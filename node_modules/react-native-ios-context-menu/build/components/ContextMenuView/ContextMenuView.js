import React from 'react';
import { StyleSheet, View, TouchableOpacity } from 'react-native';
import { TSEventEmitter } from '@dominicstop/ts-event-emitter';
import { RNIContextMenuView } from '../../native_components/RNIContextMenuView';
import { ContextMenuViewContext } from '../../context/ContextMenuViewContext';
// @ts-ignore - TODO
import { ActionSheetFallback } from '../../functions/ActionSheetFallback';
import { LIB_ENV, IS_PLATFORM_IOS } from '../../constants/LibEnv';
import * as Helpers from '../../functions/Helpers';
import { RNIDetachedView } from 'react-native-ios-utilities';
const NATIVE_ID_KEYS = {
    contextMenuPreview: 'contextMenuPreview',
    contextMenuAuxiliaryPreview: 'contextMenuAuxiliaryPreview',
};
export class ContextMenuView extends React.PureComponent {
    static defaultProps = {
        useActionSheetFallback: !LIB_ENV.isContextMenuViewSupported,
    };
    nativeRef;
    emitter;
    constructor(props) {
        super(props);
        this.state = {
            menuVisible: false,
            mountPreview: false,
        };
        this.emitter = new TSEventEmitter();
    }
    ;
    getProps = () => {
        const { useActionSheetFallback, menuConfig, previewConfig, auxiliaryPreviewConfig, shouldUseDiscoverabilityTitleAsFallbackValueForSubtitle, shouldWaitForMenuToHideBeforeFiringOnPressMenuItem, shouldEnableAggressiveCleanup, shouldCleanupOnComponentWillUnmountForMenuPreview, shouldCleanupOnComponentWillUnmountForAuxPreview, isAuxiliaryPreviewEnabled, isContextMenuEnabled, shouldPreventLongPressGestureFromPropagating, 
        // internal
        internalViewCleanupMode, debugShouldEnableLogging, 
        // event props
        onMenuWillShow, onMenuWillHide, onMenuWillCancel, onMenuDidShow, onMenuDidHide, onMenuDidCancel, onRequestDeferredElement, onMenuAuxiliaryPreviewWillShow, onMenuAuxiliaryPreviewDidShow, onPressMenuItem, onPressMenuPreview, lazyPreview, 
        // render props
        renderPreview, renderAuxiliaryPreview: renderAuxillaryPreview, ...viewProps } = this.props;
        return {
            // A. Provide default values to props...
            lazyPreview: (lazyPreview ?? true),
            useActionSheetFallback: (useActionSheetFallback ?? !LIB_ENV.isContextMenuViewSupported),
            shouldUseDiscoverabilityTitleAsFallbackValueForSubtitle: (shouldUseDiscoverabilityTitleAsFallbackValueForSubtitle ?? true),
            shouldWaitForMenuToHideBeforeFiringOnPressMenuItem: (shouldWaitForMenuToHideBeforeFiringOnPressMenuItem ?? true),
            shouldEnableAggressiveCleanup: (shouldEnableAggressiveCleanup ?? true),
            isAuxiliaryPreviewEnabled: (isAuxiliaryPreviewEnabled ?? true),
            internalViewCleanupMode: (internalViewCleanupMode ?? {
                mode: 'default',
            }),
            isContextMenuEnabled: (isContextMenuEnabled ?? true),
            shouldPreventLongPressGestureFromPropagating: (shouldPreventLongPressGestureFromPropagating ?? true),
            debugShouldEnableLogging: (debugShouldEnableLogging ?? LIB_ENV.shouldEnableLogging),
            // B. Pass down props...
            shouldCleanupOnComponentWillUnmountForMenuPreview,
            shouldCleanupOnComponentWillUnmountForAuxPreview,
            menuConfig,
            previewConfig,
            auxiliaryPreviewConfig,
            // C. Pass down, and group event props...
            eventProps: {
                onMenuWillShow,
                onMenuWillHide,
                onMenuWillCancel,
                onMenuDidShow,
                onMenuDidHide,
                onMenuDidCancel,
                onRequestDeferredElement,
                onMenuAuxiliaryPreviewWillShow,
                onMenuAuxiliaryPreviewDidShow,
                onPressMenuItem,
                onPressMenuPreview,
            },
            // D. Pass down, and group render props
            renderProps: {
                renderPreview,
                renderAuxillaryPreview,
            },
            // E. Move all the default view-related
            //    props here...
            viewProps
        };
    };
    dismissMenu = async () => {
        if (!LIB_ENV.isContextMenuViewSupported)
            return;
        await this.nativeRef.dismissMenu();
    };
    provideDeferredElements = async (deferredID, menuItems) => {
        if (!LIB_ENV.isContextMenuViewSupported)
            return;
        await this.nativeRef.provideDeferredElements(deferredID, menuItems);
    };
    presentMenu = async () => {
        if (!LIB_ENV.isContextMenuViewSupported)
            return;
        await this.nativeRef.presentMenu();
    };
    showAuxiliaryPreviewAsPopover = async () => {
        if (!LIB_ENV.isContextMenuViewSupported)
            return;
        await Helpers.setStateAsync(this, () => ({
            mountPreview: true
        }));
        await this.nativeRef.showAuxiliaryPreviewAsPopover();
    };
    //#region - Handlers
    _handleGetRefToContextMenuView = () => {
        return this;
    };
    _handleOnLongPress = async () => {
        const props = this.props;
        if (props.menuConfig == null)
            return;
        const selectedItem = await ActionSheetFallback.show(props.menuConfig);
        if (selectedItem == null) {
            // A. cancelled pressed
            props.onMenuDidCancel?.({
                isUsingActionSheetFallback: true
            });
        }
        else {
            // B. an item was selected
            props.onPressMenuItem?.({
                isUsingActionSheetFallback: true,
                nativeEvent: {
                    ...selectedItem,
                }
            });
        }
        ;
    };
    _handleOnMenuWillCreate = (event) => {
        this.setState({ mountPreview: true });
        event.stopPropagation();
    };
    _handleOnMenuWillShow = (event) => {
        this.props.onMenuWillShow?.(event);
        event.stopPropagation();
        this.setState({
            menuVisible: true,
            mountPreview: true,
        });
    };
    _handleOnMenuWillHide = (event) => {
        this.props.onMenuWillHide?.(event);
        event.stopPropagation();
        this.setState({ menuVisible: false });
    };
    _handleOnMenuWillCancel = (event) => {
        this.props.onMenuWillCancel?.(event);
        event.stopPropagation();
    };
    _handleOnMenuDidShow = (event) => {
        this.props.onMenuDidShow?.(event);
        event.stopPropagation();
    };
    _handleOnMenuDidHide = (event) => {
        this.props.onMenuDidHide?.(event);
        this.emitter.emit('onMenuDidHide', event);
        event.stopPropagation();
        event.persist();
        this.setState({ mountPreview: false });
    };
    _handleOnMenuDidCancel = (event) => {
        this.props.onMenuDidCancel?.(event);
        // guard: event is a native event
        if (event.isUsingActionSheetFallback)
            return;
        event.stopPropagation();
    };
    _handleOnRequestDeferredElement = (event) => {
        const { onRequestDeferredElement } = this.props;
        const { deferredID } = event.nativeEvent;
        onRequestDeferredElement?.(deferredID, (items) => {
            this.provideDeferredElements(deferredID, items);
        });
    };
    _handleOnMenuAuxiliaryPreviewWillShow = (event) => {
        this.props.onMenuAuxiliaryPreviewWillShow?.(event);
        event.stopPropagation();
    };
    _handleOnMenuAuxiliaryPreviewDidShow = (event) => {
        this.props.onMenuAuxiliaryPreviewDidShow?.(event);
        event.stopPropagation();
    };
    _handleOnPressMenuItem = async (event) => {
        const props = this.getProps();
        const eventProps = props.eventProps;
        // guard: event is a native event
        if (event.isUsingActionSheetFallback)
            return;
        event.stopPropagation();
        event.persist();
        const isKeepsMenuPresentedEnabled = event.nativeEvent.menuAttributes?.includes('keepsMenuPresented');
        const shouldWaitForMenuToHide = !isKeepsMenuPresentedEnabled &&
            props.shouldWaitForMenuToHideBeforeFiringOnPressMenuItem;
        try {
            if (shouldWaitForMenuToHide) {
                // wait for `onMenuDidHide`
                await Helpers.promiseWithTimeout(1000, new Promise((resolve) => {
                    this.emitter.once('onMenuDidHide', () => {
                        resolve();
                    });
                }));
                eventProps.onPressMenuItem?.(event);
            }
            else {
                eventProps.onPressMenuItem?.(event);
            }
            ;
        }
        catch (error) {
            eventProps.onPressMenuItem?.(event);
            console.log('_handleOnPressMenuItem - Promise waiting for `onMenuDidHide`'
                + ' has timed out');
        }
        ;
    };
    _handleOnPressMenuPreview = (event) => {
        this.props.onPressMenuPreview?.(event);
        event.stopPropagation();
    };
    //#endregion
    render() {
        const props = this.getProps();
        const state = this.state;
        const shouldUseContextMenuView = (LIB_ENV.isContextMenuViewSupported &&
            !props.useActionSheetFallback);
        const shouldUseActionSheetFallback = (IS_PLATFORM_IOS && props.useActionSheetFallback);
        const shouldMountPreviewContainer = (LIB_ENV.shouldEnableDetachedView
            && props.renderProps.renderPreview != null);
        const shouldMountPreviewContent = (state.mountPreview
            || !props.lazyPreview);
        const shouldMountAuxPreviewContainer = (LIB_ENV.shouldEnableDetachedView
            && props.renderProps.renderAuxillaryPreview != null);
        const shouldMountAuxPreviewContent = (state.mountPreview
            || !props.lazyPreview);
        props.debugShouldEnableLogging && console.log("ContextMenuView.render", `\n - nativeRef.reactTag: ${this.nativeRef?.reactTag ?? -1}`, `\n - shouldMountPreviewContainer: ${shouldMountPreviewContainer}`, `\n - shouldMountPreviewContent: ${shouldMountPreviewContent}`, `\n - shouldMountAuxPreviewContainer: ${shouldMountAuxPreviewContainer}`, `\n - shouldMountAuxPreviewContent: ${shouldMountAuxPreviewContent}`, `\n`);
        const contents = (shouldUseContextMenuView ? (
        // A - Use Context Menu View
        React.createElement(RNIContextMenuView, { ...props.viewProps, ref: r => { this.nativeRef = r; }, style: [styles.menuView, props.viewProps.style], menuConfig: props.menuConfig, previewConfig: props.previewConfig, auxiliaryPreviewConfig: props.auxiliaryPreviewConfig, internalViewCleanupMode: props.internalViewCleanupMode, isContextMenuEnabled: props.isContextMenuEnabled, shouldUseDiscoverabilityTitleAsFallbackValueForSubtitle: props.shouldUseDiscoverabilityTitleAsFallbackValueForSubtitle, isAuxiliaryPreviewEnabled: props.isAuxiliaryPreviewEnabled, shouldPreventLongPressGestureFromPropagating: props.shouldPreventLongPressGestureFromPropagating, debugShouldEnableLogging: props.debugShouldEnableLogging, 
            // Events: `onPress`-Related
            onMenuWillShow: this._handleOnMenuWillShow, onMenuWillHide: this._handleOnMenuWillHide, onMenuWillCancel: this._handleOnMenuWillCancel, onMenuDidShow: this._handleOnMenuDidShow, onMenuDidHide: this._handleOnMenuDidHide, onMenuDidCancel: this._handleOnMenuDidCancel, onRequestDeferredElement: this._handleOnRequestDeferredElement, onMenuWillCreate: this._handleOnMenuWillCreate, 
            // Events: "Aux. Preview"-Related
            onMenuAuxiliaryPreviewWillShow: this._handleOnMenuAuxiliaryPreviewWillShow, onMenuAuxiliaryPreviewDidShow: this._handleOnMenuAuxiliaryPreviewDidShow, 
            // Events: `onPress`-Related
            onPressMenuItem: this._handleOnPressMenuItem, onPressMenuPreview: this._handleOnPressMenuPreview },
            shouldMountPreviewContainer && (React.createElement(RNIDetachedView, { contentTargetMode: 'wrapper', nativeID: NATIVE_ID_KEYS.contextMenuPreview, internalViewCleanupMode: {
                    mode: 'enabled',
                    triggers: ['reactComponentWillUnmount'],
                }, shouldCleanupOnComponentWillUnmount: true }, shouldMountPreviewContent && (props.renderProps.renderPreview?.()))),
            shouldMountAuxPreviewContainer && (React.createElement(RNIDetachedView, { contentTargetMode: 'wrapper', nativeID: NATIVE_ID_KEYS.contextMenuAuxiliaryPreview, shouldCleanupOnComponentWillUnmount: true, internalViewCleanupMode: {
                    mode: 'enabled',
                    triggers: ['reactComponentWillUnmount'],
                } }, shouldMountAuxPreviewContent && (props.renderProps.renderAuxillaryPreview?.()))),
            props.viewProps.children)) : shouldUseActionSheetFallback ? (
        // B - Use Context Menu Fallback
        React.createElement(TouchableOpacity, { onLongPress: this._handleOnLongPress, activeOpacity: 0.8, ...props.viewProps }, this.props.children)) : (
        // C - Use Regular View
        React.createElement(View, { ...props.viewProps }, this.props.children)));
        return (React.createElement(ContextMenuViewContext.Provider, { value: {
                getRefToContextMenuView: this._handleGetRefToContextMenuView,
                isMenuVisible: state.menuVisible,
            } }, contents));
    }
    ;
}
;
const styles = StyleSheet.create({
    menuView: {
        backgroundColor: 'transparent',
    },
});
//# sourceMappingURL=ContextMenuView.js.map